//! Utilities for executing generated [`ByteCode`](crate::bytecode::ByteCode).

use std::prelude::v1::*;
use std::collections::{BTreeMap, BTreeSet};
use std::cell::RefCell;
use std::rc::{Rc, Weak};
use std::iter;

use derive_builder::Builder;
use serde_json::Value as Json;

use crate::bytecode::*;
use crate::runtime::*;

/// An execution error from a [`Process`] (see [`Process::step`]).
/// 
/// Each error variant contains a field called `pos` which is the [`ByteCode`] index at the time of the error.
/// By using the [`Locations`] information from [`ByteCode::compile`], it is possible to determine which
/// script/function generated the error.
#[derive(Debug)]
pub enum ExecError {
    /// A variable lookup operation failed.
    /// `name` holds the name of the variable that was expected.
    UndefinedVariable { name: String, pos: usize },
    /// An upgrade operation on a [`Weak`] handle for a [`Value::List`] failed.
    /// Proper usage of this crate should never generate this error.
    /// The most likely cause is that a [`RefPool`] instance was improperly used.
    ListUpgradeError { weak: Weak<RefCell<Vec<Value>>>, pos: usize },
    /// An upgrade operation on a [`Weak`] handle for a [`Value::Closure`] failed.
    /// Proper usage of this crate should never generate this error.
    /// The most likely cause is that a [`RefPool`] instance was improperly used.
    ClosureUpgradeError { weak: Weak<RefCell<Closure>>, pos: usize },
    /// The result of a failed type conversion.
    ConversionError { got: Type, expected: Type, pos: usize },
    /// Attempt to index a list with a non-integer numeric value, `index`.
    IndexNotInteger { index: f64, pos: usize },
    /// An indexing operation on a list had an out of bounds index, `index`, on a list of size `list_len`.
    /// Note that Snap!/NetsBlox use 1-based indexing.
    IndexOutOfBounds { index: f64, list_len: usize, pos: usize },
    /// Exceeded the maximum call depth.
    /// This can be configured by [`Process::new`].
    CallDepthLimit { limit: usize, pos: usize },
    /// Attempt to call a closure which required `expected` arguments, but `got` arguments were supplied.
    ClosureArgCount { expected: usize, got: usize, pos: usize },
    /// An operation resulted in an error generated by the [`System`].
    SystemError { error: SystemError, pos: usize },
    /// Attempt to parse an invalid JSON-encoded string.
    NotJson { value: Rc<String>, pos: usize },
    /// Attempt to parse a JSON-encoded string that contained a null value.
    JsonHadNull { value: Rc<String>, pos: usize },
    /// Attempt to parse a JSON-encoded string that contained an number that could not be encoded as [`f64`].
    JsonHadBadNumber { value: Rc<String>, pos: usize },
    /// Attempt to interpret an invalid unicode code point (number) as a character.
    InvalidUnicode { value: f64, pos: usize },
}

enum IndexError {
    NotInteger { index: f64 },
    OutOfBounds { index: f64, list_len: usize },
}
enum EncodingError {
    NotJson { value: Rc<String> },
    JsonHadNull { value: Rc<String> },
    JsonHadBadNumber { value: Rc<String> },
    InvalidUnicode { value: f64 },
}

enum OpError {
    ConversionError(ConversionError),
    ListUpgradeError(ListUpgradeError),
    IndexError(IndexError),
    EncodingError(EncodingError),
}
trivial_from_impl! { OpError: ConversionError, ListUpgradeError, IndexError, EncodingError }

trait ErrAt {
    fn err_at(self, pos: usize) -> ExecError;
}
impl ErrAt for ConversionError {
    fn err_at(self, pos: usize) -> ExecError { ExecError::ConversionError { got: self.got, expected: self.expected, pos } }
}
impl ErrAt for ListUpgradeError {
    fn err_at(self, pos: usize) -> ExecError { ExecError::ListUpgradeError { weak: self.weak, pos } }
}
impl ErrAt for ClosureUpgradeError {
    fn err_at(self, pos: usize) -> ExecError { ExecError::ClosureUpgradeError { weak: self.weak, pos } }
}
impl ErrAt for IndexError {
    fn err_at(self, pos: usize) -> ExecError {
        match self {
            IndexError::NotInteger { index } => ExecError::IndexNotInteger { index, pos },
            IndexError::OutOfBounds { index, list_len } => ExecError::IndexOutOfBounds { index, list_len, pos },
        }
    }
}
impl ErrAt for EncodingError {
    fn err_at(self, pos: usize) -> ExecError {
        match self {
            EncodingError::NotJson { value } => ExecError::NotJson { value, pos },
            EncodingError::JsonHadNull { value } => ExecError::JsonHadNull { value, pos },
            EncodingError::JsonHadBadNumber { value } => ExecError::JsonHadBadNumber { value, pos },
            EncodingError::InvalidUnicode { value } => ExecError::InvalidUnicode { value, pos },
        }
    }
}
impl ErrAt for SystemError {
    fn err_at(self, pos: usize) -> ExecError { ExecError::SystemError { error: self, pos } }
}

macro_rules! trivial_err_at_impl {
    ($t:ident : $($f:ident),*$(,)?) => {
        impl ErrAt for $t {
            fn err_at(self, pos: usize) -> ExecError { match self { $($t::$f(e) => e.err_at(pos)),* } }
        }
    }
}
trivial_err_at_impl! { ListConversionError: ConversionError, ListUpgradeError }
trivial_err_at_impl! { ClosureConversionError: ConversionError, ClosureUpgradeError }
trivial_err_at_impl! { OpError: ConversionError, ListUpgradeError, IndexError, EncodingError }

/// Result of stepping through a [`Process`].
pub enum StepType {
    /// The process was not running.
    Idle,
    /// The process executed an instruction successfully and does not need to yield.
    Normal,
    /// The process has signaled a yield point so that other code can run.
    /// Many yield results may occur back-to-back, such as while awaiting an asynchronous result.
    /// 
    /// Yielding is primarily needed for executing an entire semi-concurrent project so that scripts can appear to run simultaneously.
    /// If instead you are explicitly only using a single sandboxed process, this can be treated equivalently to [`StepType::Normal`].
    Yield,
    /// The process has successfully terminated with the given return value, or `None` if terminated by an (error-less) abort
    Terminate(Option<Value>),
}

struct ReturnPoint {
    pos: usize,
    warp_counter: usize,
    value_stack_size: usize,
}

#[derive(Builder)]
#[builder(no_std)]
#[derive(Clone, Copy)]
pub struct Settings {
    /// The maximum depth of the call stack (default `1024`).
    #[builder(default = "1024")]
    max_call_depth: usize,
}

/// A [`ByteCode`] execution primitive.
/// 
/// A `Process` is a self-contained thread of execution; it maintains its own state machine for executing instructions step by step.
/// Global variables, entity fields, and several external features are hosted separately and passed into [`Process::step`].
pub struct Process<S: System> {
    code: Rc<ByteCode>,
    pos: usize,
    warp_counter: usize,
    running: bool,
    settings: Settings,
    call_stack: Vec<(ReturnPoint, SymbolTable)>, // tuples of (ret pos, locals)
    value_stack: Vec<Value>,
    async_req: Option<S::AsyncKey>,
}
impl<S: System> Process<S> {
    /// Creates a new process with the given code.
    /// The new process is initially idle; [`Process::initialize`] can be used to begin execution at a specific location (see [`Locations`]).
    pub fn new(code: Rc<ByteCode>, settings: Settings) -> Self {
        Self {
            code, settings,
            pos: 0,
            warp_counter: 0,
            running: false,
            call_stack: vec![],
            value_stack: vec![],
            async_req: None,
        }
    }
    /// Checks if the process is currently running.
    /// Note that the process will not run on its own (see [`Process::step`]).
    pub fn is_running(&self) -> bool {
        self.running
    }
    /// Gets a reference to the [`ByteCode`] object that the process was built from.
    pub fn get_code(&self) -> &Rc<ByteCode> {
        &self.code
    }
    /// Prepares the process to execute code at the given [`ByteCode`] position
    /// and with the given context of local variables.
    /// Any previous process state is wiped when performing this action.
    pub fn initialize(&mut self, start_pos: usize, context: SymbolTable) {
        self.pos = start_pos;
        self.warp_counter = 0;
        self.running = true;
        self.call_stack.clear();
        self.call_stack.push((ReturnPoint { pos: usize::MAX, warp_counter: 0, value_stack_size: 0 }, context));
        self.value_stack.clear();
    }
    /// Executes a single instruction with the given execution context.
    /// The return value can be used to determine what additional effects the script has requested,
    /// as well as retrieving the return value or execution error in the event that the process terminates.
    /// 
    /// The process transitions to the idle state (see [`Process::is_running`]) upon failing with `Err` or
    /// succeeding with [`StepType::Terminate`].
    pub fn step(&mut self, ref_pool: &mut RefPool, system: &mut S, project: &mut ProjectInfo, entity: &Entity) -> Result<StepType, ExecError> {
        let res = self.step_impl(ref_pool, system, project, entity);
        if let Ok(StepType::Terminate(_)) | Err(_) = res {
            self.running = false;
        }
        res
    }
    fn step_impl(&mut self, ref_pool: &mut RefPool, system: &mut S, project: &mut ProjectInfo, entity: &Entity) -> Result<StepType, ExecError> {
        if !self.running { return Ok(StepType::Idle); }
        let (_, locals) = self.call_stack.last_mut().unwrap();
        let mut fields = entity.fields.borrow_mut();
        let mut context = [&mut project.globals, &mut *fields, locals];
        let mut context = LookupGroup::new(&mut context);

        macro_rules! lookup_var {
            ($var:expr => $m:ident) => {{
                let var = $var;
                match context.$m(var) {
                    Some(x) => x,
                    None => return Err(ExecError::UndefinedVariable { name: var.into(), pos: self.pos }),
                }
            }};
            ($var:expr) => {lookup_var!($var => lookup)};
            (mut $var:expr) => {lookup_var!($var => lookup_mut)};
        }

        match &self.code.0[self.pos] {
            Instruction::Illegal => panic!(),

            Instruction::Yield => {
                self.pos += 1;
                if self.warp_counter == 0 { return Ok(StepType::Yield) }
            }
            Instruction::WarpStart => {
                self.warp_counter += 1;
                self.pos += 1;
            }
            Instruction::WarpStop => {
                self.warp_counter -= 1;
                self.pos += 1;
            }

            Instruction::PushValue { value } => {
                self.value_stack.push(Value::from_ast(value, ref_pool, true));
                self.pos += 1;
            }
            Instruction::PushVariable { var } => {
                self.value_stack.push(lookup_var!(var).get_clone());
                self.pos += 1;
            }
            Instruction::DupeValue { top_index } => {
                let val = self.value_stack[self.value_stack.len() - 1 - top_index].clone();
                self.value_stack.push(val);
                self.pos += 1;
            }
            Instruction::SwapValues { top_index_1, top_index_2 } => {
                let len = self.value_stack.len();
                self.value_stack.swap(len - 1 - top_index_1, len - 1 - top_index_2);
                self.pos += 1;
            }
            Instruction::PopValues { count } => {
                let len = self.value_stack.len();
                self.value_stack.drain(len - count..);
                debug_assert_eq!(self.value_stack.len(), len - count);
                self.pos += 1;
            }

            Instruction::ShallowCopy => {
                let val = self.value_stack.pop().unwrap();
                self.value_stack.push(val.shallow_copy(ref_pool).map_err(|e| e.err_at(self.pos))?);
                self.pos += 1;
            }

            Instruction::MakeList { len } => {
                let mut vals = Vec::with_capacity(*len);
                for _ in 0..*len {
                    vals.push(self.value_stack.pop().unwrap());
                }
                vals.reverse();
                self.value_stack.push(Value::from_vec(vals, ref_pool));
                self.pos += 1;
            }
            Instruction::ListLen => {
                let list = self.value_stack.pop().unwrap().to_list().map_err(|e| e.err_at(self.pos))?;
                self.value_stack.push((list.borrow().len() as f64).into());
                self.pos += 1;
            }
            Instruction::ListIndex => {
                let index = self.value_stack.pop().unwrap();
                let list = self.value_stack.pop().unwrap();
                self.value_stack.push(ops::index_list(&list, &index, ref_pool).map_err(|e| e.err_at(self.pos))?);
                self.pos += 1;
            }
            Instruction::ListLastIndex => {
                let list = self.value_stack.pop().unwrap().to_list().map_err(|e| e.err_at(self.pos))?;
                self.value_stack.push(match list.borrow().last() {
                    Some(x) => x.clone(),
                    None => return Err(IndexError::OutOfBounds { index: 0.0, list_len: 0 }.err_at(self.pos)),
                });
                self.pos += 1;
            }
            Instruction::MakeListRange => {
                let b = self.value_stack.pop().unwrap().to_number().map_err(|e| e.err_at(self.pos))?;
                let mut a = self.value_stack.pop().unwrap().to_number().map_err(|e| e.err_at(self.pos))?;

                let mut res = vec![];
                if a.is_finite() && b.is_finite() {
                    if a <= b {
                        while a <= b {
                            res.push(a.into());
                            a += 1.0;
                        }
                    } else {
                        while a >= b {
                            res.push(a.into());
                            a -= 1.0;
                        }
                    }
                }

                self.value_stack.push(Value::from_vec(res, ref_pool));
                self.pos += 1;
            }
            Instruction::ListPush => {
                let val = self.value_stack.pop().unwrap();
                let list = self.value_stack.pop().unwrap().to_list().map_err(|e| e.err_at(self.pos))?;
                list.borrow_mut().push(val);
                self.pos += 1;
            }
            Instruction::ListIndexAssign => {
                let value = self.value_stack.pop().unwrap();
                let index = self.value_stack.pop().unwrap();
                let list = self.value_stack.pop().unwrap().to_list().map_err(|e| e.err_at(self.pos))?;
                let mut list = list.borrow_mut();
                let index = ops::prep_list_index(&index, list.len()).map_err(|e| e.err_at(self.pos))?;
                list[index] = value;
                self.pos += 1;
            }

            Instruction::Strcat { args } => {
                let mut values = Vec::with_capacity(*args);
                for _ in 0..*args {
                    values.push(self.value_stack.pop().unwrap());
                }
                let mut res = String::new();
                for value in values.iter().rev() {
                    res += value.to_string().map_err(|e| e.err_at(self.pos))?.as_str();
                }
                self.value_stack.push(Value::from_string(res, ref_pool, false));
                self.pos += 1;
            }

            Instruction::BinaryOp { op } => {
                let b = self.value_stack.pop().unwrap();
                let a = self.value_stack.pop().unwrap();
                self.value_stack.push(ops::binary_op(&a, &b, ref_pool, *op).map_err(|e| e.err_at(self.pos))?);
                self.pos += 1;
            }
            Instruction::Eq => {
                let b = self.value_stack.pop().unwrap();
                let a = self.value_stack.pop().unwrap();
                self.value_stack.push(ops::check_eq(&a, &b).map_err(|e| e.err_at(self.pos))?.into());
                self.pos += 1;
            }
            Instruction::UnaryOp { op } => {
                let x = self.value_stack.pop().unwrap();
                self.value_stack.push(ops::unary_op(&x, ref_pool, *op).map_err(|e| e.err_at(self.pos))?);
                self.pos += 1;
            }

            Instruction::DeclareLocals { vars } => {
                let locals = context.locals_mut();
                for var in vars {
                    locals.redefine_or_define(var, Shared::Unique(0.0.into()));
                }
                self.pos += 1;
            }
            Instruction::Assign { var } => {
                let value = self.value_stack.pop().unwrap();
                context.set_or_define(var, value.clone());
                self.pos += 1;
            }
            Instruction::BinaryOpAssign { var, op } => {
                let b = self.value_stack.pop().unwrap();
                let a = lookup_var!(var).get_clone();
                context.set_or_define(var, ops::binary_op(&a, &b, ref_pool, *op).map_err(|e| e.err_at(self.pos))?);
                self.pos += 1;
            }

            Instruction::Jump { to } => self.pos = *to,
            Instruction::ConditionalJump { to, when } => {
                let value = self.value_stack.pop().unwrap();
                self.pos = if value.to_bool().map_err(|e| e.err_at(self.pos))? == *when { *to } else { self.pos + 1 };
            }

            Instruction::Call { pos, params } => {
                if self.call_stack.len() >= self.settings.max_call_depth {
                    return Err(ExecError::CallDepthLimit { limit: self.settings.max_call_depth, pos: self.pos });
                }

                let mut context = SymbolTable::default();
                for var in params.iter().rev() {
                    context.redefine_or_define(var, self.value_stack.pop().unwrap().into());
                }
                self.call_stack.push((ReturnPoint { pos: self.pos + 1, warp_counter: self.warp_counter, value_stack_size: self.value_stack.len() }, context));
                self.pos = *pos;
            }
            Instruction::MakeClosure { pos, params, captures } => {
                let mut context = SymbolTable::default();
                for var in captures {
                    context.redefine_or_define(var, lookup_var!(mut var).alias());
                }
                self.value_stack.push(Value::from_closure(Closure { pos: *pos, params: params.clone(), captures: context }, ref_pool));
                self.pos += 1;
            }
            Instruction::CallClosure { args } => {
                let closure = self.value_stack.pop().unwrap().to_closure().map_err(|e| e.err_at(self.pos))?;
                let mut closure = closure.borrow_mut();
                if closure.params.len() != *args {
                    return Err(ExecError::ClosureArgCount { expected: closure.params.len(), got: *args, pos: self.pos });
                }

                let mut context = SymbolTable::default();
                for (k, v) in closure.captures.iter_mut() {
                    context.redefine_or_define(k, v.alias());
                }
                for var in closure.params.iter().rev() {
                    context.redefine_or_define(var, self.value_stack.pop().unwrap().into());
                }
                self.call_stack.push((ReturnPoint { pos: self.pos + 1, warp_counter: self.warp_counter, value_stack_size: self.value_stack.len() }, context));
                self.pos = closure.pos;
            }
            Instruction::Return => {
                let (return_point, _) = self.call_stack.pop().unwrap();
                let return_value = self.value_stack.pop().unwrap();
                self.value_stack.drain(return_point.value_stack_size..);
                debug_assert_eq!(self.value_stack.len(), return_point.value_stack_size);
                self.value_stack.push(return_value);

                if self.call_stack.is_empty() {
                    debug_assert_eq!(self.value_stack.len(), 1);
                    debug_assert_eq!(return_point.pos, usize::MAX);
                    debug_assert_eq!(return_point.warp_counter, 0);
                    debug_assert_eq!(return_point.value_stack_size, 0);
                    return Ok(StepType::Terminate(Some(self.value_stack.pop().unwrap())));
                } else {
                    self.pos = return_point.pos;
                    self.warp_counter = return_point.warp_counter;
                }
            }
        }

        Ok(StepType::Normal)
    }
}

mod ops {
    use super::*;

    fn as_list(v: &Value) -> Result<Option<Rc<RefCell<Vec<Value>>>>, ListUpgradeError> {
        Ok(match v {
            Value::List(v) => Some(v.checked_upgrade()?),
            _ => None,
        })
    }
    fn as_matrix(v: &Value) -> Result<Option<Rc<RefCell<Vec<Value>>>>, ListUpgradeError> {
        Ok(match as_list(v)? {
            Some(vals) => {
                let good = match vals.borrow().as_slice() {
                    [] => false,
                    [first, ..] => as_list(first)?.is_some(),
                };
                if good { Some(vals) } else { None }
            }
            None => None,
        })
    }

    fn json_to_value(json: Json, ref_pool: &mut RefPool, value: &Rc<String>) -> Result<Value, EncodingError> {
        Ok(match json {
            Json::Null => return Err(EncodingError::JsonHadNull { value: value.clone() }),
            Json::Bool(x) => x.into(),
            Json::Number(x) => match x.as_f64() {
                Some(x) => x.into(),
                None => return Err(EncodingError::JsonHadBadNumber { value: value.clone() }),
            }
            Json::String(x) => Value::from_string(x, ref_pool, false),
            Json::Array(x) => Value::from_vec(x.into_iter().map(|x| json_to_value(x, ref_pool, value)).collect::<Result<_,_>>()?, ref_pool),
            Json::Object(x) => Value::from_vec(x.into_iter().map(|(k, v)| Ok(Value::from_vec(vec![
                Value::from_string(k, ref_pool, false),
                json_to_value(v, ref_pool, value)?,
            ], ref_pool))).collect::<Result<_,_>>()?, ref_pool),
        })
    }

    pub(super) fn prep_list_index(index: &Value, list_len: usize) -> Result<usize, OpError> {
        let raw_index = index.to_number()?;
        if raw_index < 1.0 || raw_index > list_len as f64 { return Err(IndexError::OutOfBounds { index: raw_index, list_len }.into()) }
        let index = raw_index as u64;
        if index as f64 != raw_index { return Err(IndexError::NotInteger { index: raw_index }.into()) }
        Ok(index as usize - 1)
    }

    const DEG_TO_RAD: f64 = std::f64::consts::PI / 180.0;

    fn binary_op_impl(a: &Value, b: &Value, matrix_mode: bool, cache: &mut BTreeMap<(*const (), *const (), bool), Value>, ref_pool: &mut RefPool, scalar_op: fn(&Value, &Value, &mut RefPool) -> Result<Value, OpError>) -> Result<Value, OpError> {
        let cache_key = (a.alloc_ptr(), b.alloc_ptr(), matrix_mode);
        Ok(match cache.get(&cache_key) {
            Some(x) => x.clone(),
            None => {
                let checker = if matrix_mode { as_matrix } else { as_list };
                match (checker(a)?, checker(b)?) {
                    (Some(a), Some(b)) => {
                        let (a, b) = (a.borrow(), b.borrow());
                        let real_res = Value::from_vec(Vec::with_capacity(a.len().min(b.len())), ref_pool);
                        cache.insert(cache_key, real_res.clone());
                        let res = as_list(&real_res)?.unwrap();
                        let mut res = res.borrow_mut();
                        for (a, b) in iter::zip(&*a, &*b) {
                            res.push(binary_op_impl(a, b, matrix_mode, cache, ref_pool, scalar_op)?);
                        }
                        real_res
                    }
                    (Some(a), None) => {
                        let a = a.borrow();
                        let real_res = Value::from_vec(Vec::with_capacity(a.len()), ref_pool);
                        cache.insert(cache_key, real_res.clone());
                        let res = as_list(&real_res)?.unwrap();
                        let mut res = res.borrow_mut();
                        for a in &*a {
                            res.push(binary_op_impl(a, b, matrix_mode, cache, ref_pool, scalar_op)?);
                        }
                        real_res
                    }
                    (None, Some(b)) => {
                        let b = b.borrow();
                        let real_res = Value::from_vec(Vec::with_capacity(b.len()), ref_pool);
                        cache.insert(cache_key, real_res.clone());
                        let res = as_list(&real_res)?.unwrap();
                        let mut res = res.borrow_mut();
                        for b in &*b {
                            res.push(binary_op_impl(a, b, matrix_mode, cache, ref_pool, scalar_op)?);
                        }
                        real_res
                    }
                    (None, None) => if matrix_mode { binary_op_impl(a, b, false, cache, ref_pool, scalar_op)? } else { scalar_op(a, b, ref_pool)? }
                }
            }
        })
    }
    pub(super) fn binary_op(a: &Value, b: &Value, ref_pool: &mut RefPool, op: BinaryOp) -> Result<Value, OpError> {
        match op {
            BinaryOp::Add     => binary_op_impl(a, b, true, &mut Default::default(), ref_pool, |a, b, _| Ok((a.to_number()? + b.to_number()?).into())),
            BinaryOp::Sub     => binary_op_impl(a, b, true, &mut Default::default(), ref_pool, |a, b, _| Ok((a.to_number()? - b.to_number()?).into())),
            BinaryOp::Mul     => binary_op_impl(a, b, true, &mut Default::default(), ref_pool, |a, b, _| Ok((a.to_number()? * b.to_number()?).into())),
            BinaryOp::Div     => binary_op_impl(a, b, true, &mut Default::default(), ref_pool, |a, b, _| Ok((a.to_number()? / b.to_number()?).into())),
            BinaryOp::Pow     => binary_op_impl(a, b, true, &mut Default::default(), ref_pool, |a, b, _| Ok(libm::pow(a.to_number()?, b.to_number()?).into())),
            BinaryOp::Log     => binary_op_impl(a, b, true, &mut Default::default(), ref_pool, |a, b, _| Ok((libm::log2(b.to_number()?) / libm::log2(a.to_number()?)).into())),
            BinaryOp::Greater => binary_op_impl(a, b, true, &mut Default::default(), ref_pool, |a, b, _| Ok((a.to_number()? > b.to_number()?).into())),
            BinaryOp::Less    => binary_op_impl(a, b, true, &mut Default::default(), ref_pool, |a, b, _| Ok((a.to_number()? < b.to_number()?).into())),
            BinaryOp::Mod     => binary_op_impl(a, b, true, &mut Default::default(), ref_pool, |a, b, _| {
                let (a, b) = (a.to_number()?, b.to_number()?);
                Ok(if a.is_sign_positive() == b.is_sign_positive() { a % b } else { b + (a % -b) }.into())
            }),

            BinaryOp::SplitCustom => binary_op_impl(a, b, true, &mut Default::default(), ref_pool, |a, b, ref_pool| {
                let (text, pattern) = (a.to_string()?, b.to_string()?);
                Ok(Value::from_vec(text.split(pattern.as_str()).map(|x| Value::from_string(x.into(), ref_pool, false)).collect(), ref_pool))
            }),
        }
    }

    fn unary_op_impl(x: &Value, cache: &mut BTreeMap<*const (), Value>, ref_pool: &mut RefPool, scalar_op: &dyn Fn(&Value, &mut RefPool) -> Result<Value, OpError>) -> Result<Value, OpError> {
        let cache_key = x.alloc_ptr();
        Ok(match cache.get(&cache_key) {
            Some(x) => x.clone(),
            None => match as_list(x)? {
                Some(x) => {
                    let x = x.borrow();
                    let real_res = Value::from_vec(Vec::with_capacity(x.len()), ref_pool);
                    cache.insert(cache_key, real_res.clone());
                    let res = as_list(&real_res)?.unwrap();
                    let mut res = res.borrow_mut();
                    for x in &*x {
                        res.push(unary_op_impl(x, cache, ref_pool, scalar_op)?);
                    }
                    real_res
                }
                None => scalar_op(x, ref_pool)?,
            }
        })
    }
    pub(super) fn unary_op(x: &Value, ref_pool: &mut RefPool, op: UnaryOp) -> Result<Value, OpError> {
        match op {
            UnaryOp::ToBool => unary_op_impl(x, &mut Default::default(), ref_pool, &|x, _| Ok(x.to_bool()?.into())),
            UnaryOp::Not    => unary_op_impl(x, &mut Default::default(), ref_pool, &|x, _| Ok((!x.to_bool()?).into())),
            UnaryOp::Abs    => unary_op_impl(x, &mut Default::default(), ref_pool, &|x, _| Ok(libm::fabs(x.to_number()?).into())),
            UnaryOp::Neg    => unary_op_impl(x, &mut Default::default(), ref_pool, &|x, _| Ok((-x.to_number()?).into())),
            UnaryOp::Sqrt   => unary_op_impl(x, &mut Default::default(), ref_pool, &|x, _| Ok(libm::sqrt(x.to_number()?).into())),
            UnaryOp::Round  => unary_op_impl(x, &mut Default::default(), ref_pool, &|x, _| Ok(libm::round(x.to_number()?).into())),
            UnaryOp::Floor  => unary_op_impl(x, &mut Default::default(), ref_pool, &|x, _| Ok(libm::floor(x.to_number()?).into())),
            UnaryOp::Ceil   => unary_op_impl(x, &mut Default::default(), ref_pool, &|x, _| Ok(libm::ceil(x.to_number()?).into())),
            UnaryOp::Sin    => unary_op_impl(x, &mut Default::default(), ref_pool, &|x, _| Ok(libm::sin(x.to_number()? * DEG_TO_RAD).into())),
            UnaryOp::Cos    => unary_op_impl(x, &mut Default::default(), ref_pool, &|x, _| Ok(libm::cos(x.to_number()? * DEG_TO_RAD).into())),
            UnaryOp::Tan    => unary_op_impl(x, &mut Default::default(), ref_pool, &|x, _| Ok(libm::tan(x.to_number()? * DEG_TO_RAD).into())),
            UnaryOp::Asin   => unary_op_impl(x, &mut Default::default(), ref_pool, &|x, _| Ok((libm::asin(x.to_number()?) / DEG_TO_RAD).into())),
            UnaryOp::Acos   => unary_op_impl(x, &mut Default::default(), ref_pool, &|x, _| Ok((libm::acos(x.to_number()?) / DEG_TO_RAD).into())),
            UnaryOp::Atan   => unary_op_impl(x, &mut Default::default(), ref_pool, &|x, _| Ok((libm::atan(x.to_number()?) / DEG_TO_RAD).into())),
            UnaryOp::Strlen => unary_op_impl(x, &mut Default::default(), ref_pool, &|x, _| Ok((x.to_string()?.chars().count() as f64).into())),

            UnaryOp::SplitLetter => unary_op_impl(x, &mut Default::default(), ref_pool, &|x, ref_pool| {
                Ok(Value::from_vec(x.to_string()?.chars().map(|x| Value::from_string(x.into(), ref_pool, false)).collect(), ref_pool))
            }),
            UnaryOp::SplitWord => unary_op_impl(x, &mut Default::default(), ref_pool, &|x, ref_pool| {
                Ok(Value::from_vec(x.to_string()?.split_whitespace().map(|x| Value::from_string(x.into(), ref_pool, false)).collect(), ref_pool))
            }),
            UnaryOp::SplitTab => unary_op_impl(x, &mut Default::default(), ref_pool, &|x, ref_pool| {
                Ok(Value::from_vec(x.to_string()?.split('\t').map(|x| Value::from_string(x.into(), ref_pool, false)).collect(), ref_pool))
            }),
            UnaryOp::SplitCR => unary_op_impl(x, &mut Default::default(), ref_pool, &|x, ref_pool| {
                Ok(Value::from_vec(x.to_string()?.split('\r').map(|x| Value::from_string(x.into(), ref_pool, false)).collect(), ref_pool))
            }),
            UnaryOp::SplitLF => unary_op_impl(x, &mut Default::default(), ref_pool, &|x, ref_pool| {
                Ok(Value::from_vec(x.to_string()?.lines().map(|x| Value::from_string(x.into(), ref_pool, false)).collect(), ref_pool))
            }),
            UnaryOp::SplitCsv => unary_op_impl(x, &mut Default::default(), ref_pool, &|x, ref_pool| {
                let lines: Vec<_> = x.to_string()?.lines().map(|line| Value::from_vec(line.split(',').map(|x| Value::from_string(x.into(), ref_pool, false)).collect(), ref_pool)).collect();
                Ok(match lines.len() {
                    1 => lines.into_iter().next().unwrap(),
                    _ => Value::from_vec(lines, ref_pool),
                })
            }),
            UnaryOp::SplitJson => unary_op_impl(x, &mut Default::default(), ref_pool, &|x, ref_pool| {
                let value = x.to_string()?;
                match serde_json::from_str(value.as_str()) {
                    Ok(json) => Ok(json_to_value(json, ref_pool, &value)?),
                    Err(_) => Err(OpError::EncodingError(EncodingError::NotJson { value })),
                }
            }),

            UnaryOp::UnicodeToChar => unary_op_impl(x, &mut Default::default(), ref_pool, &|x, ref_pool| {
                let fnum = x.to_number()?;
                if fnum < 0.0 || fnum > u32::MAX as f64 { return Err(OpError::EncodingError(EncodingError::InvalidUnicode { value: fnum })) }
                let num = fnum as u32;
                if num as f64 != fnum { return Err(OpError::EncodingError(EncodingError::InvalidUnicode { value: fnum })) }
                match char::from_u32(num) {
                    Some(ch) => Ok(Value::from_string(ch.to_string(), ref_pool, false)),
                    None => Err(OpError::EncodingError(EncodingError::InvalidUnicode { value: fnum })),
                }
            }),
            UnaryOp::CharToUnicode => unary_op_impl(x, &mut Default::default(), ref_pool, &|x, ref_pool| {
                let src = x.to_string()?;
                let values: Vec<Value> = src.chars().map(|ch| (ch as u32 as f64).into()).collect();
                Ok(match values.len() {
                    1 => values.into_iter().next().unwrap(),
                    _ => Value::from_vec(values, ref_pool),
                })
            }),
        }
    }
    pub(super) fn index_list(list: &Value, index: &Value, ref_pool: &mut RefPool) -> Result<Value, OpError> {
        let list = match as_list(list)? {
            Some(x) => x,
            None => return Err(ConversionError { got: list.get_type(), expected: Type::List }.into()),
        };
        let list = list.borrow();
        unary_op_impl(index, &mut Default::default(), ref_pool, &|x, _| Ok(list[prep_list_index(x, list.len())?].clone()))
    }

    fn check_eq_impl(a: &Value, b: &Value, cache: &mut BTreeSet<(*const (), *const ())>) -> Result<bool, ListUpgradeError> {
        // if already cached, that cmp handles overall check, so no-op with true (if we ever get a false, the whole thing is false)
        if !cache.insert((a.alloc_ptr(), b.alloc_ptr())) { return Ok(true) }

        Ok(match (a, b) {
            (Value::Bool(a), Value::Bool(b)) => *a == *b,
            (Value::Bool(_), _) | (_, Value::Bool(_)) => false,

            (Value::Number(a), Value::Number(b)) => *a == *b,
            (Value::String(a), Value::String(b)) => a.to_lowercase() == b.to_lowercase(),
            (Value::Number(n), Value::String(s)) | (Value::String(s), Value::Number(n)) => match s.parse::<f64>() {
                Ok(s) => s == *n,
                Err(_) => **s == n.to_string(),
            }

            (Value::Closure(a), Value::Closure(b)) => a.as_ptr() == b.as_ptr(),
            (Value::Closure(_), _) | (_, Value::Closure(_)) => false,

            (Value::List(a), Value::List(b)) => {
                let (a, b) = (a.checked_upgrade()?, b.checked_upgrade()?);
                let (a, b) = (a.borrow(), b.borrow());
                if a.len() != b.len() { return Ok(false) }
                for (a, b) in iter::zip(&*a, &*b) {
                    if !check_eq_impl(a, b, cache)? { return Ok(false) }
                }
                true
            }
            (Value::List(_), _) | (_, Value::List(_)) => false,

            (Value::Entity(a), Value::Entity(b)) => a.as_ptr() == b.as_ptr(),
            (Value::Entity(_), _) | (_, Value::Entity(_)) => false,
        })
    }
    pub(super) fn check_eq(a: &Value, b: &Value) -> Result<bool, ListUpgradeError> {
        check_eq_impl(a, b, &mut Default::default())
    }
}
